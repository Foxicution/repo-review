{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/fox/Projects/Python/repo-review/streamlit_components/graph_visualizer/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/home/fox/Projects/Python/repo-review/streamlit_components/graph_visualizer/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/fox/Projects/Python/repo-review/streamlit_components/graph_visualizer/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/fox/Projects/Python/repo-review/streamlit_components/graph_visualizer/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/home/fox/Projects/Python/repo-review/streamlit_components/graph_visualizer/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _awaitAsyncGenerator from \"/home/fox/Projects/Python/repo-review/streamlit_components/graph_visualizer/frontend/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/home/fox/Projects/Python/repo-review/streamlit_components/graph_visualizer/frontend/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(_fromIterable);\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { toUint8Array, joinUint8Arrays, toUint8ArrayIterator, toUint8ArrayAsyncIterator } from '../util/buffer';\n/** @ignore */\nexport default {\n  fromIterable: function fromIterable(source) {\n    return pump(_fromIterable(source));\n  },\n  fromAsyncIterable: function fromAsyncIterable(source) {\n    return pump(_fromAsyncIterable2(source));\n  },\n  fromDOMStream: function fromDOMStream(source) {\n    return pump(_fromDOMStream2(source));\n  },\n  fromNodeStream: function fromNodeStream(stream) {\n    return pump(_fromNodeStream2(stream));\n  },\n  // @ts-ignore\n  toDOMStream: function toDOMStream(source, options) {\n    throw new Error(\"\\\"toDOMStream\\\" not available in this environment\");\n  },\n  // @ts-ignore\n  toNodeStream: function toNodeStream(source, options) {\n    throw new Error(\"\\\"toNodeStream\\\" not available in this environment\");\n  }\n};\n/** @ignore */\nvar pump = function pump(iterator) {\n  iterator.next();\n  return iterator;\n};\n/** @ignore */\nfunction _fromIterable(source) {\n  var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield, it, _ref, _yield$byteRange;\n  return _regeneratorRuntime().wrap(function _fromIterable$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          byteRange = function _byteRange() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n            var _joinUint8Arrays = joinUint8Arrays(buffers, size);\n            var _joinUint8Arrays2 = _slicedToArray(_joinUint8Arrays, 3);\n            buffer = _joinUint8Arrays2[0];\n            buffers = _joinUint8Arrays2[1];\n            bufferLength = _joinUint8Arrays2[2];\n            return buffer;\n          };\n          threw = false;\n          buffers = [];\n          bufferLength = 0;\n          _context.next = 6;\n          return null;\n        case 6:\n          _yield = _context.sent;\n          cmd = _yield.cmd;\n          size = _yield.size;\n          // initialize the iterator\n          it = toUint8ArrayIterator(source)[Symbol.iterator]();\n          _context.prev = 10;\n        case 11:\n          // read the next value\n          _ref = isNaN(size - bufferLength) ? it.next(undefined) : it.next(size - bufferLength);\n          done = _ref.done;\n          buffer = _ref.value;\n          // if chunk is not null or empty, push it onto the queue\n          if (!done && buffer.byteLength > 0) {\n            buffers.push(buffer);\n            bufferLength += buffer.byteLength;\n          }\n          // If we have enough bytes in our buffer, yield chunks until we don't\n          if (!(done || size <= bufferLength)) {\n            _context.next = 22;\n            break;\n          }\n        case 16:\n          _context.next = 18;\n          return byteRange();\n        case 18:\n          _yield$byteRange = _context.sent;\n          cmd = _yield$byteRange.cmd;\n          size = _yield$byteRange.size;\n        case 21:\n          if (size < bufferLength) {\n            _context.next = 16;\n            break;\n          }\n        case 22:\n          if (!done) {\n            _context.next = 11;\n            break;\n          }\n        case 23:\n          _context.next = 28;\n          break;\n        case 25:\n          _context.prev = 25;\n          _context.t0 = _context[\"catch\"](10);\n          (threw = true) && typeof it.throw === 'function' && it.throw(_context.t0);\n        case 28:\n          _context.prev = 28;\n          threw === false && typeof it.return === 'function' && it.return();\n          return _context.finish(28);\n        case 31:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[10, 25, 28, 31]]);\n}\n/** @ignore */\nfunction _fromAsyncIterable2(_x) {\n  return _fromAsyncIterable.apply(this, arguments);\n} // All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nfunction _fromAsyncIterable() {\n  _fromAsyncIterable = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield2, it, _ref2, _yield$byteRange2;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            byteRange = function _byteRange2() {\n              if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n              }\n              var _joinUint8Arrays3 = joinUint8Arrays(buffers, size);\n              var _joinUint8Arrays4 = _slicedToArray(_joinUint8Arrays3, 3);\n              buffer = _joinUint8Arrays4[0];\n              buffers = _joinUint8Arrays4[1];\n              bufferLength = _joinUint8Arrays4[2];\n              return buffer;\n            };\n            threw = false;\n            buffers = [];\n            bufferLength = 0;\n            _context2.next = 6;\n            return null;\n          case 6:\n            _yield2 = _context2.sent;\n            cmd = _yield2.cmd;\n            size = _yield2.size;\n            // initialize the iterator\n            it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n            _context2.prev = 10;\n          case 11:\n            if (!isNaN(size - bufferLength)) {\n              _context2.next = 17;\n              break;\n            }\n            _context2.next = 14;\n            return _awaitAsyncGenerator(it.next(undefined));\n          case 14:\n            _context2.t0 = _context2.sent;\n            _context2.next = 20;\n            break;\n          case 17:\n            _context2.next = 19;\n            return _awaitAsyncGenerator(it.next(size - bufferLength));\n          case 19:\n            _context2.t0 = _context2.sent;\n          case 20:\n            _ref2 = _context2.t0;\n            done = _ref2.done;\n            buffer = _ref2.value;\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n              buffers.push(buffer);\n              bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (!(done || size <= bufferLength)) {\n              _context2.next = 31;\n              break;\n            }\n          case 25:\n            _context2.next = 27;\n            return byteRange();\n          case 27:\n            _yield$byteRange2 = _context2.sent;\n            cmd = _yield$byteRange2.cmd;\n            size = _yield$byteRange2.size;\n          case 30:\n            if (size < bufferLength) {\n              _context2.next = 25;\n              break;\n            }\n          case 31:\n            if (!done) {\n              _context2.next = 11;\n              break;\n            }\n          case 32:\n            _context2.next = 40;\n            break;\n          case 34:\n            _context2.prev = 34;\n            _context2.t1 = _context2[\"catch\"](10);\n            _context2.t2 = (threw = true) && typeof it.throw === 'function';\n            if (!_context2.t2) {\n              _context2.next = 40;\n              break;\n            }\n            _context2.next = 40;\n            return _awaitAsyncGenerator(it.throw(_context2.t1));\n          case 40:\n            _context2.prev = 40;\n            _context2.t3 = threw === false && typeof it.return === 'function';\n            if (!_context2.t3) {\n              _context2.next = 45;\n              break;\n            }\n            _context2.next = 45;\n            return _awaitAsyncGenerator(it.return());\n          case 45:\n            return _context2.finish(40);\n          case 46:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, null, [[10, 34, 40, 46]]);\n  }));\n  return _fromAsyncIterable.apply(this, arguments);\n}\nfunction _fromDOMStream2(_x2) {\n  return _fromDOMStream.apply(this, arguments);\n}\n/** @ignore */\nfunction _fromDOMStream() {\n  _fromDOMStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield3, it, _ref3, _yield$byteRange3;\n    return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            byteRange = function _byteRange3() {\n              if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n              }\n              var _joinUint8Arrays5 = joinUint8Arrays(buffers, size);\n              var _joinUint8Arrays6 = _slicedToArray(_joinUint8Arrays5, 3);\n              buffer = _joinUint8Arrays6[0];\n              buffers = _joinUint8Arrays6[1];\n              bufferLength = _joinUint8Arrays6[2];\n              return buffer;\n            };\n            done = false, threw = false;\n            buffers = [];\n            bufferLength = 0;\n            _context3.next = 6;\n            return null;\n          case 6:\n            _yield3 = _context3.sent;\n            cmd = _yield3.cmd;\n            size = _yield3.size;\n            // initialize the reader and lock the stream\n            it = new AdaptiveByteReader(source);\n            _context3.prev = 10;\n          case 11:\n            if (!isNaN(size - bufferLength)) {\n              _context3.next = 17;\n              break;\n            }\n            _context3.next = 14;\n            return _awaitAsyncGenerator(it['read'](undefined));\n          case 14:\n            _context3.t0 = _context3.sent;\n            _context3.next = 20;\n            break;\n          case 17:\n            _context3.next = 19;\n            return _awaitAsyncGenerator(it['read'](size - bufferLength));\n          case 19:\n            _context3.t0 = _context3.sent;\n          case 20:\n            _ref3 = _context3.t0;\n            done = _ref3.done;\n            buffer = _ref3.value;\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n              buffers.push(toUint8Array(buffer));\n              bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (!(done || size <= bufferLength)) {\n              _context3.next = 31;\n              break;\n            }\n          case 25:\n            _context3.next = 27;\n            return byteRange();\n          case 27:\n            _yield$byteRange3 = _context3.sent;\n            cmd = _yield$byteRange3.cmd;\n            size = _yield$byteRange3.size;\n          case 30:\n            if (size < bufferLength) {\n              _context3.next = 25;\n              break;\n            }\n          case 31:\n            if (!done) {\n              _context3.next = 11;\n              break;\n            }\n          case 32:\n            _context3.next = 40;\n            break;\n          case 34:\n            _context3.prev = 34;\n            _context3.t1 = _context3[\"catch\"](10);\n            _context3.t2 = threw = true;\n            if (!_context3.t2) {\n              _context3.next = 40;\n              break;\n            }\n            _context3.next = 40;\n            return _awaitAsyncGenerator(it['cancel'](_context3.t1));\n          case 40:\n            _context3.prev = 40;\n            if (!(threw === false)) {\n              _context3.next = 46;\n              break;\n            }\n            _context3.next = 44;\n            return _awaitAsyncGenerator(it['cancel']());\n          case 44:\n            _context3.next = 47;\n            break;\n          case 46:\n            source['locked'] && it.releaseLock();\n          case 47:\n            return _context3.finish(40);\n          case 48:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2, null, [[10, 34, 40, 48]]);\n  }));\n  return _fromDOMStream.apply(this, arguments);\n}\nvar AdaptiveByteReader = /*#__PURE__*/function () {\n  function AdaptiveByteReader(source) {\n    _classCallCheck(this, AdaptiveByteReader);\n    this.source = source;\n    this.byobReader = null;\n    this.defaultReader = null;\n    try {\n      this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n    } catch (e) {\n      this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n    }\n  }\n  _createClass(AdaptiveByteReader, [{\n    key: \"closed\",\n    get: function get() {\n      return this.reader ? this.reader['closed'].catch(function () {}) : Promise.resolve();\n    }\n  }, {\n    key: \"releaseLock\",\n    value: function releaseLock() {\n      if (this.reader) {\n        this.reader.releaseLock();\n      }\n      this.reader = this.byobReader = this.defaultReader = null;\n    }\n  }, {\n    key: \"cancel\",\n    value: function () {\n      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(reason) {\n        var reader, source;\n        return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                reader = this.reader, source = this.source;\n                _context4.t0 = reader;\n                if (!_context4.t0) {\n                  _context4.next = 5;\n                  break;\n                }\n                _context4.next = 5;\n                return reader['cancel'](reason).catch(function () {});\n              case 5:\n                source && source['locked'] && this.releaseLock();\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function cancel(_x4) {\n        return _cancel.apply(this, arguments);\n      }\n      return cancel;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(size) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(size === 0)) {\n                  _context5.next = 2;\n                  break;\n                }\n                return _context5.abrupt(\"return\", {\n                  done: this.reader == null,\n                  value: new Uint8Array(0)\n                });\n              case 2:\n                if (!(!this.supportsBYOB || typeof size !== 'number')) {\n                  _context5.next = 8;\n                  break;\n                }\n                _context5.next = 5;\n                return this.getDefaultReader().read();\n              case 5:\n                _context5.t0 = _context5.sent;\n                _context5.next = 11;\n                break;\n              case 8:\n                _context5.next = 10;\n                return this.readFromBYOBReader(size);\n              case 10:\n                _context5.t0 = _context5.sent;\n              case 11:\n                result = _context5.t0;\n                !result.done && (result.value = toUint8Array(result));\n                return _context5.abrupt(\"return\", result);\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function read(_x5) {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n  }, {\n    key: \"getDefaultReader\",\n    value: function getDefaultReader() {\n      if (this.byobReader) {\n        this.releaseLock();\n      }\n      if (!this.defaultReader) {\n        this.defaultReader = this.source['getReader']();\n        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n        this.defaultReader['closed'].catch(function () {});\n      }\n      return this.reader = this.defaultReader;\n    }\n  }, {\n    key: \"getBYOBReader\",\n    value: function getBYOBReader() {\n      if (this.defaultReader) {\n        this.releaseLock();\n      }\n      if (!this.byobReader) {\n        this.byobReader = this.source['getReader']({\n          mode: 'byob'\n        });\n        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n        this.byobReader['closed'].catch(function () {});\n      }\n      return this.reader = this.byobReader;\n    }\n    // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n  }, {\n    key: \"readFromBYOBReader\",\n    value: function () {\n      var _readFromBYOBReader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(size) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n              case 2:\n                return _context6.abrupt(\"return\", _context6.sent);\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function readFromBYOBReader(_x6) {\n        return _readFromBYOBReader.apply(this, arguments);\n      }\n      return readFromBYOBReader;\n    }()\n  }]);\n  return AdaptiveByteReader;\n}();\n/** @ignore */\nfunction readInto(_x7, _x8, _x9, _x10) {\n  return _readInto.apply(this, arguments);\n}\n/** @ignore */\nfunction _readInto() {\n  _readInto = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(reader, buffer, offset, size) {\n    var _yield$reader$read, done, value;\n    return _regeneratorRuntime().wrap(function _callee8$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            if (!(offset >= size)) {\n              _context9.next = 2;\n              break;\n            }\n            return _context9.abrupt(\"return\", {\n              done: false,\n              value: new Uint8Array(buffer, 0, size)\n            });\n          case 2:\n            _context9.next = 4;\n            return reader.read(new Uint8Array(buffer, offset, size - offset));\n          case 4:\n            _yield$reader$read = _context9.sent;\n            done = _yield$reader$read.done;\n            value = _yield$reader$read.value;\n            if (!((offset += value.byteLength) < size && !done)) {\n              _context9.next = 11;\n              break;\n            }\n            _context9.next = 10;\n            return readInto(reader, value.buffer, offset, size);\n          case 10:\n            return _context9.abrupt(\"return\", _context9.sent);\n          case 11:\n            return _context9.abrupt(\"return\", {\n              done: done,\n              value: new Uint8Array(value.buffer, 0, offset)\n            });\n          case 12:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _readInto.apply(this, arguments);\n}\nvar onEvent = function onEvent(stream, event) {\n  var handler = function handler(_) {\n    return resolve([event, _]);\n  };\n  var resolve;\n  return [event, handler, new Promise(function (r) {\n    return (resolve = r) && stream['once'](event, handler);\n  })];\n};\n/** @ignore */\nfunction _fromNodeStream2(_x3) {\n  return _fromNodeStream.apply(this, arguments);\n}\nfunction _fromNodeStream() {\n  _fromNodeStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(stream) {\n    var events, event, done, err, cmd, size, bufferLength, buffers, buffer, byteRange, _yield4, _yield$_awaitAsyncGen, _yield$_awaitAsyncGen2, _yield$byteRange4, cleanup;\n    return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            cleanup = function _cleanup(events, err) {\n              buffer = buffers = null;\n              return new Promise( /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(resolve, reject) {\n                  var _iterator, _step, _step$value, evt, fn, destroy;\n                  return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          _iterator = _createForOfIteratorHelper(events);\n                          try {\n                            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                              _step$value = _slicedToArray(_step.value, 2), evt = _step$value[0], fn = _step$value[1];\n                              stream['off'](evt, fn);\n                            }\n                          } catch (err) {\n                            _iterator.e(err);\n                          } finally {\n                            _iterator.f();\n                          }\n                          try {\n                            // Some stream implementations don't call the destroy callback,\n                            // because it's really a node-internal API. Just calling `destroy`\n                            // here should be enough to conform to the ReadableStream contract\n                            destroy = stream['destroy'];\n                            destroy && destroy.call(stream, err);\n                            err = undefined;\n                          } catch (e) {\n                            err = e || err;\n                          } finally {\n                            err != null ? reject(err) : resolve();\n                          }\n                        case 3:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _callee6);\n                }));\n                return function (_x11, _x12) {\n                  return _ref4.apply(this, arguments);\n                };\n              }());\n            };\n            byteRange = function _byteRange4() {\n              if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n              }\n              var _joinUint8Arrays7 = joinUint8Arrays(buffers, size);\n              var _joinUint8Arrays8 = _slicedToArray(_joinUint8Arrays7, 3);\n              buffer = _joinUint8Arrays8[0];\n              buffers = _joinUint8Arrays8[1];\n              bufferLength = _joinUint8Arrays8[2];\n              return buffer;\n            };\n            events = [];\n            event = 'error';\n            done = false, err = null;\n            bufferLength = 0;\n            buffers = [];\n            _context8.next = 9;\n            return null;\n          case 9:\n            _yield4 = _context8.sent;\n            cmd = _yield4.cmd;\n            size = _yield4.size;\n            if (!stream['isTTY']) {\n              _context8.next = 16;\n              break;\n            }\n            _context8.next = 15;\n            return new Uint8Array(0);\n          case 15:\n            return _context8.abrupt(\"return\", _context8.sent);\n          case 16:\n            _context8.prev = 16;\n            // initialize the stream event handlers\n            events[0] = onEvent(stream, 'end');\n            events[1] = onEvent(stream, 'error');\n          case 19:\n            events[2] = onEvent(stream, 'readable');\n            // wait on the first message event from the stream\n            _context8.next = 22;\n            return _awaitAsyncGenerator(Promise.race(events.map(function (x) {\n              return x[2];\n            })));\n          case 22:\n            _yield$_awaitAsyncGen = _context8.sent;\n            _yield$_awaitAsyncGen2 = _slicedToArray(_yield$_awaitAsyncGen, 2);\n            event = _yield$_awaitAsyncGen2[0];\n            err = _yield$_awaitAsyncGen2[1];\n            if (!(event === 'error')) {\n              _context8.next = 28;\n              break;\n            }\n            return _context8.abrupt(\"break\", 37);\n          case 28:\n            if (!(done = event === 'end')) {\n              // If the size is NaN, request to read everything in the stream's internal buffer\n              if (!isFinite(size - bufferLength)) {\n                buffer = toUint8Array(stream['read'](undefined));\n              } else {\n                buffer = toUint8Array(stream['read'](size - bufferLength));\n                // If the byteLength is 0, then the requested amount is more than the stream has\n                // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                // continue emitting readable events, so request to read everything the stream\n                // has in its internal buffer right now.\n                if (buffer.byteLength < size - bufferLength) {\n                  buffer = toUint8Array(stream['read'](undefined));\n                }\n              }\n              // if chunk is not null or empty, push it onto the queue\n              if (buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n              }\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (!(done || size <= bufferLength)) {\n              _context8.next = 36;\n              break;\n            }\n          case 30:\n            _context8.next = 32;\n            return byteRange();\n          case 32:\n            _yield$byteRange4 = _context8.sent;\n            cmd = _yield$byteRange4.cmd;\n            size = _yield$byteRange4.size;\n          case 35:\n            if (size < bufferLength) {\n              _context8.next = 30;\n              break;\n            }\n          case 36:\n            if (!done) {\n              _context8.next = 19;\n              break;\n            }\n          case 37:\n            _context8.prev = 37;\n            _context8.next = 40;\n            return _awaitAsyncGenerator(cleanup(events, event === 'error' ? err : null));\n          case 40:\n            return _context8.finish(37);\n          case 41:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee7, null, [[16,, 37, 41]]);\n  }));\n  return _fromNodeStream.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["fromIterable","toUint8Array","joinUint8Arrays","toUint8ArrayIterator","toUint8ArrayAsyncIterator","source","pump","fromAsyncIterable","fromDOMStream","fromNodeStream","stream","toDOMStream","options","Error","toNodeStream","iterator","next","byteRange","cmd","buffers","size","buffer","bufferLength","threw","it","Symbol","isNaN","undefined","done","value","byteLength","push","throw","return","asyncIterator","AdaptiveByteReader","releaseLock","supportsBYOB","reader","getBYOBReader","e","getDefaultReader","catch","Promise","resolve","byobReader","defaultReader","reason","Uint8Array","read","readFromBYOBReader","result","mode","readInto","ArrayBuffer","offset","onEvent","event","handler","_","r","cleanup","events","err","reject","evt","fn","destroy","call","race","map","x","isFinite"],"sources":["io/adapters.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport {\n    toUint8Array,\n    joinUint8Arrays,\n    ArrayBufferViewInput,\n    toUint8ArrayIterator,\n    toUint8ArrayAsyncIterator\n} from '../util/buffer';\n\nimport { ReadableDOMStreamOptions } from './interfaces';\n\n/** @ignore */\nexport default {\n    fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n        return pump(fromIterable<T>(source));\n    },\n    fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromAsyncIterable<T>(source));\n    },\n    fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromDOMStream<T>(source));\n    },\n    fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: ReadableDOMStreamOptions): ReadableStream<T> {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: import('stream').ReadableOptions): import('stream').Readable {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n\n/** @ignore */\nconst pump = <T extends Iterator<any> | AsyncIterator<any>>(iterator: T) => { iterator.next(); return iterator; };\n\n/** @ignore */\nfunction* fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayIterator(source)[Symbol.iterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength) ?\n                it.next(undefined) : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return());\n    }\n}\n\n/** @ignore */\nasync function* fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source AsyncIterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it.next(undefined)\n                : await it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (await it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (await it.return());\n    }\n}\n\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nasync function* fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done = false, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we establish the ReadableStream lock\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the reader and lock the stream\n    let it = new AdaptiveByteReader(source);\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it['read'](undefined)\n                : await it['read'](size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(toUint8Array(buffer));\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (await it['cancel'](e));\n    } finally {\n        (threw === false) ? (await it['cancel']())\n            : source['locked'] && it.releaseLock();\n    }\n}\n\n/** @ignore */\nclass AdaptiveByteReader<T extends ArrayBufferViewInput> {\n\n    private supportsBYOB: boolean;\n    private byobReader: ReadableStreamBYOBReader | null = null;\n    private defaultReader: ReadableStreamDefaultReader<T> | null = null;\n    private reader: ReadableStreamBYOBReader | ReadableStreamDefaultReader<T> | null;\n\n    constructor(private source: ReadableStream<T>) {\n        try {\n            this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n        } catch (e) {\n            this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n        }\n    }\n\n    get closed(): Promise<void> {\n        return this.reader ? this.reader['closed'].catch(() => {}) : Promise.resolve();\n    }\n\n    releaseLock(): void {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = this.byobReader = this.defaultReader = null;\n    }\n\n    async cancel(reason?: any): Promise<void> {\n        const { reader, source } = this;\n        reader && (await reader['cancel'](reason).catch(() => {}));\n        source && (source['locked'] && this.releaseLock());\n    }\n\n    async read(size?: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n        if (size === 0) {\n            return { done: this.reader == null, value: new Uint8Array(0) };\n        }\n        const result = !this.supportsBYOB || typeof size !== 'number'\n            ? await this.getDefaultReader().read()\n            : await this.readFromBYOBReader(size);\n        !result.done && (result.value = toUint8Array(result as ReadableStreamReadResult<Uint8Array>));\n        return result as ReadableStreamReadResult<Uint8Array>;\n    }\n\n    private getDefaultReader() {\n        if (this.byobReader) { this.releaseLock(); }\n        if (!this.defaultReader) {\n            this.defaultReader = this.source['getReader']();\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.defaultReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.defaultReader);\n    }\n\n    private getBYOBReader() {\n        if (this.defaultReader) { this.releaseLock(); }\n        if (!this.byobReader) {\n            this.byobReader = this.source['getReader']({ mode: 'byob' });\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.byobReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.byobReader);\n    }\n\n    // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n    private async readFromBYOBReader(size: number) {\n        return await readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n    }\n}\n\n/** @ignore */\nasync function readInto(reader: ReadableStreamBYOBReader, buffer: ArrayBufferLike, offset: number, size: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n    if (offset >= size) {\n        return { done: false, value: new Uint8Array(buffer, 0, size) };\n    }\n    const { done, value } = await reader.read(new Uint8Array(buffer, offset, size - offset));\n    if (((offset += value.byteLength) < size) && !done) {\n        return await readInto(reader, value.buffer, offset, size);\n    }\n    return { done, value: new Uint8Array(value.buffer, 0, offset) };\n}\n\n/** @ignore */\ntype EventName = 'end' | 'error' | 'readable';\n/** @ignore */\ntype Event = [EventName, (_: any) => void, Promise<[EventName, Error | null]>];\n/** @ignore */\nconst onEvent = <T extends string>(stream: NodeJS.ReadableStream, event: T) => {\n    let handler = (_: any) => resolve([event, _]);\n    let resolve: (value?: [T, any] | PromiseLike<[T, any]>) => void;\n    return [event, handler, new Promise<[T, any]>(\n        (r) => (resolve = r) && stream['once'](event, handler)\n    )] as Event;\n};\n\n/** @ignore */\nasync function* fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n\n    let events: Event[] = [];\n    let event: EventName = 'error';\n    let done = false, err: Error | null = null;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array | Buffer | string;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we\n    // add the listener for the source stream's 'readable' event.\n    ({ cmd, size } = yield <any> null);\n\n    // ignore stdin if it's a TTY\n    if ((stream as any)['isTTY']) { return yield new Uint8Array(0); }\n\n    try {\n        // initialize the stream event handlers\n        events[0] = onEvent(stream, 'end');\n        events[1] = onEvent(stream, 'error');\n\n        do {\n            events[2] = onEvent(stream, 'readable');\n\n            // wait on the first message event from the stream\n            [event, err] = await Promise.race(events.map((x) => x[2]));\n\n            // if the stream emitted an Error, rethrow it\n            if (event === 'error') { break; }\n            if (!(done = event === 'end')) {\n                // If the size is NaN, request to read everything in the stream's internal buffer\n                if (!isFinite(size - bufferLength)) {\n                    buffer = toUint8Array(stream['read'](undefined));\n                } else {\n                    buffer = toUint8Array(stream['read'](size - bufferLength));\n                    // If the byteLength is 0, then the requested amount is more than the stream has\n                    // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                    // continue emitting readable events, so request to read everything the stream\n                    // has in its internal buffer right now.\n                    if (buffer.byteLength < (size - bufferLength)) {\n                        buffer = toUint8Array(stream['read'](undefined));\n                    }\n                }\n                // if chunk is not null or empty, push it onto the queue\n                if (buffer.byteLength > 0) {\n                    buffers.push(buffer);\n                    bufferLength += buffer.byteLength;\n                }\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } finally {\n        await cleanup(events, event === 'error' ? err : null);\n    }\n\n    function cleanup<T extends Error | null | void>(events: Event[], err?: T) {\n        buffer = buffers = <any> null;\n        return new Promise<T>(async (resolve, reject) => {\n            for (const [evt, fn] of events) {\n                stream['off'](evt, fn);\n            }\n            try {\n                // Some stream implementations don't call the destroy callback,\n                // because it's really a node-internal API. Just calling `destroy`\n                // here should be enough to conform to the ReadableStream contract\n                const destroy = (stream as any)['destroy'];\n                destroy && destroy.call(stream, err);\n                err = undefined;\n            } catch (e) { err = e || err; } finally {\n                err != null ? reject(err) : resolve();\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}